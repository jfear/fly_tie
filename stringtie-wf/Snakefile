import sys
sys.path.insert(0, srcdir('../lcdb-wf'))
import os
from pathlib import Path
from textwrap import dedent
import yaml
import tempfile
import pandas as pd
from lcdblib.snakemake import helpers, aligners
from lcdblib.utils import utils
from lib import common
from lib import cluster_specific


configfile: 'config/config.yaml'
include: '../references-wf/Snakefile'
shell.prefix('set -euo pipefail; export TMPDIR={};'.format(cluster_specific.tempdir_for_biowulf()))
shell.executable('/bin/bash')

# Global variables from config
REFERENCES_DIR = os.environ['REFERENCES_DIR']
ORGANISM = config['organism']
ALIGNER = config['aligner']['index']
TAG = config['aligner']['tag']

# load filename patterns
with open(config['patterns']) as fh:
    patterns = yaml.load(fh.read())

# read sampletable
sampletable = pd.read_csv(config['sampletable'], sep='\t', index_col=0)
srxs = sampletable.index.unique().tolist()

# ----------------------------------------------------------------------------
# RULES
# ----------------------------------------------------------------------------
wildcard_constraints:
    n="[1,2]"

localrules: targets, bamList

# TODO add code to make stringtie params.

targets = (
    expand(patterns['bam'], sample=srxs)
)


rule targets:
    input: patterns['stringtie']


rule fastq_dump:
    output: temp(patterns['fastq'])
    params:
        sampletable = sampletable
    resources:
        mem_gb = lambda wildcards, attempt: attempt * 2,
        time_hr = lambda wildcards, attempt: attempt * 4
    script: 'scripts/fastq_dump.py'


def _cutadapt(wildcards):
    fastq_pth = Path(patterns['fastq'].format(sample=wildcards.sample, n=1))
    return [str(fname) for fname in fastq_pth.parent.glob('*_R[1,2].fastq.gz')]


rule cutadapt:
    input: _cutadapt
    output: patterns['cutadapt']
    params:
        extra = '-a file:../lcdb-wf/include/adapters.fa -q 20 --minimum-length=25'
    log: patterns['cutadapt'] + '.log'
    resources:
        mem_gb = lambda wildcards, attempt: attempt * 8,
        time_hr = lambda wildcards, attempt: attempt * 4
    script: 'scripts/cutadapt.py'


def _hisat2(wildcards):
    fastq_pth = Path(patterns['fastq'].format(sample=wildcards.sample, n=1))
    return sorted([str(fname) for fname in fastq_pth.parent.glob('*_R[1,2].cutadapt.fastq.gz')])


rule hisat2:
    input:
        fastq =_hisat2,
        index = f'{REFERENCES_DIR}/{ORGANISM}/{TAG}/{ALIGNER}/{ORGANISM}_{TAG}.1.ht2'
    output:
        bam=patterns['bam']
    log: patterns['bam'] + '.log'
    params:
        samtools_view_extra='-F 0x04'
    threads: 6
    resources:
        mem_gb = lambda wildcards, attempt: attempt * 8,
        time_hr = lambda wildcards, attempt: attempt * 4
    script: '../lcdb-wf/wrappers/wrappers/hisat2/align/wrapper.py'


rule bam_index:
    input: '{prefix}.bam'
    output: '{prefix}.bam.bai'
    shell: 'samtools index {input} {output}'


def _bamList(wildcards):
    fnames = []
    for srx in srxs:
        fnames.append(patterns['bam'].format(sample=srx))
    return fnames


rule bamList:
    input: _bamList
    output: patterns['bamList']
    run:
        with open(output[0], 'w') as fh:
            fh.write('\n'.join(input))


rule mergeBam:
    input: rules.bamList.output[0]
    output: patterns['merged_bam']
    threads: 12
    resources:
        mem_gb = lambda wildcards, attempt: attempt * 30,
        time_hr = lambda wildcards, attempt: attempt * 24
    shell: "samtools merge -b {input} -@ {threads} {output[0]}"


rule stringtie:
    input:
        bam = rules.mergeBam.output[0],
        gtf = f'{REFERENCES_DIR}/{ORGANISM}/{TAG}/gtf/{ORGANISM}_{TAG}.gtf'
    output: patterns['stringtie']
    threads: 12
    resources:
        mem_gb = lambda wildcards, attempt: attempt * 62,
        time_hr = lambda wildcards, attempt: attempt * 24
    shell: "stringtie {input.bam} -G {input.gtf} -p {threads} -o {output[0]}"


# TODO add GFF compare or some other metric

# vim: ft=python
